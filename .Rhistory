bdays <- sample(1:365, k, replace = TRUE)
matches[n] <- sum(table(bdays)>=3)
}
mean(matches)
}
sim(40)
k=40
nrep <- 5000
matches <- rep(0, nrep)
sim <- function(k, nrep=5000) {
set.seed(1)
matches <- rep(0, nrep)
for (n in 1:nrep) {
bdays <- sample(1:365, k, replace = TRUE)
matches[n] <- max(table(bdays))
}
mean(matches>=3)
}
sim(40)
1:nrep
1:365
bdays <- sample(1:365, k, replace = TRUE)
bdays
table(bdays)
?table
2*(2.170+1.036)^2*6.45/4
68/0.8^2
library(MASS)
set.seed(1)
vals <- c(0,2,9)
probs <- c(.5,.3,.2)  # <-- corrected
mu <- sum(vals*probs)
mu
sig2 <- sum((vals-mu)^2 * probs)
sig <- sqrt(sig2)
sig
spins <- sample(c(0,2,9),20,prob=c(.5,.3,.2),replace=T)
spins
mean(spins)
# collect many means
set.seed(1)
nmeans <- 10000  # of times we will repeat experiment of getting a mean
nspin <- 20       # of spins per mean (this is "n" in the LLN)
means <- rep(0, nmeans)  # our vector to collect results
for(i in 1:nmeans){
spins <- sample(c(0,2,9), nspin, prob=c(.5,.3,.2), replace=T)
means[i] <- mean(spins)
}
nspin=2000       # of spins per mean
means <- rep(0, nmeans)  # our vector to collect results
for(i in 1:nmeans){
spins <- sample(c(0,2,9), nspin, prob=c(.5,.3,.2), replace=T)
means[i] <- mean(spins)
}
means
means2000 <- means
truehist(means2000)
rg <- range(means20)
means20 <- means
library(MASS)
truehist(means20)
means20 <- means
library(MASS)
truehist(means20)
nspin=2000       # of spins per mean
means <- rep(0, nmeans)  # our vector to collect results
for(i in 1:nmeans){
spins <- sample(c(0,2,9), nspin, prob=c(.5,.3,.2), replace=T)
means[i] <- mean(spins)
}
means2000 <- means
truehist(means2000)
rg <- range(means20)
truehist(means20, xlim=rg)
truehist(means2000, xlim=rg)
mean(means20>2.3 & means20<2.5)
mean(means2000>2.3 & means2000<2.5)
vals <- c(0,2,9)
probs <- c(.5,.3,.2)  # <-- corrected
mu <- sum(vals*probs)
mu
sig2 <- sum((vals-mu)^2 * probs)
sig <- sqrt(sig2)
sig
# get a mean, one at a time
spins <- sample(c(0,2,9),20,prob=c(.5,.3,.2),replace=T)
spins
mean(spins)
# collect many means
set.seed(1)
nmeans <- 10000  # of times we will repeat experiment of getting a mean
nspin <- 20       # of spins per mean (this is "n" in the LLN)
means <- rep(0, nmeans)  # our vector to collect results
for(i in 1:nmeans){
spins <- sample(c(0,2,9), nspin, prob=c(.5,.3,.2), replace=T)
means[i] <- mean(spins)
}
means20 <- means
library(MASS)
truehist(means20)
nspin=2000       # of spins per mean
means <- rep(0, nmeans)  # our vector to collect results
for(i in 1:nmeans){
spins <- sample(c(0,2,9), nspin, prob=c(.5,.3,.2), replace=T)
means[i] <- mean(spins)
}
means2000 <- means
truehist(means2000)
rg <- range(means20)
truehist(means20, xlim=rg)
truehist(means2000, xlim=rg)
mean(means20>2.3 & means20<2.5)
mean(means2000>2.3 & means2000<2.5)
means20>2.3 & means20<2.5
mean(means20>2.3 & means20<2.5)
mean(means2000>2.3 & means2000<2.5)
?model.matrix
form
d
head(d)
form
dim(d)
dim(complete.cases(d))
length(complete.cases(d))
m <- model.matrix(form, d) # model matrix will drop the NAs
dim(m)
head(m)
sum(complete.cases(d))
data(pima)
dim(pima)
test_ind <- sample.int(nrow(pima), 50)
train_ind <- setdiff(1:nrow(pima), test_ind)
fit <- ridge_reg(form, 1, pima[train_ind,])
error <- pima$glucose[test_ind] - predict(fit, pima[test_ind,])
mse <- foreach(lambda = lambda_seq, .combine = c) %do% {
fit <- ridge_reg(form, lambda, pima[train_ind,])
error <- pima$glucose[test_ind] - predict(fit, pima[test_ind,])
mean(error^2)
}
# use %do% in foreach library is slower
system.time({
mse <- foreach(lambda = lambda_seq, .combine = c, .export = c("predict.ridge_reg")) %do% {
fit <- ridge_reg(form, lambda, pima[train_ind,])
error <- pima$glucose[test_ind] - predict(fit, pima[test_ind,])
mean(error^2)
}
})
mean(error^2)
?pnorm
pnorm(1.2)
# mornal
pnorm(1.2) - 0.5
?polygon
?pnorm
?dnorm
seq(-10, 10, by=0.1)
zs <- seq(-10, 10, by=0.1)
dnorm(zs)
ds <- dnorm(zs)
plot(zs, ds)
ds <- dnorm(zs, mean = 80.7, sd = 9.2)
plot(zs, ds)
zs <- seq(0, 160, by=0.1)
ds <- dnorm(zs, mean = 80.7, sd = 9.2)
plot(zs, ds)
d2s <- dnorm(zs, mean = 94.9, sd = 11.5)
curve(dnorm(mean = 94.9, sd = 11.5), add = TRUE)
?pnorm
setwd("~/Documents/Master2-2/BIS 557-Computational Statistics/homework 1/bis557")
ridge_test <- read_csv("~/Documents/Master2-2/BIS 557-Computational Statistics/homework 2/ridge_test.csv")
ridge_test <- read.csv("~/Documents/Master2-2/BIS 557-Computational Statistics/homework 2/ridge_test.csv")
ridge_train <- read.csv("~/Documents/Master2-2/BIS 557-Computational Statistics/homework 2/ridge_train.csv")
library(devtools)
devtools::use_data(ridge_test, ridge_train, overwrite = T)
install.packages("sinew")
devtools::install_github("mdlincoln/docthis")
sinew::makeOxygen(ridge_train, add_fields = "source")
getwd()
data("ridge_train")
data("ridge_test")
head(ridge_train)
summary(ridge_train)
m <- model.matrix(formula, data)
formula <- y~.
data <- ridge_train
m <- model.matrix(formula, data)
head(m)
as.character(formula)
as.character(formula)[2]
data[,as.character(formula)[2]]
matrix(data[,as.character(formula)[2]], ncol=1)
head(matrix(data[,as.character(formula)[2]], ncol=1))
matrix(data[,as.character(formula)[2], drop=FALSE], ncol=1)
data[,as.character(formula)[2], drop=FALSE]
y <- matrix(d[,as.character(form)[2]], ncol=1)
length(y)
y <- matrix(data[,as.character(formula)[2]], ncol=1)
length(y)
dim(m)
m <- model.matrix(formula, data)
head(m)
rownames(data) <- NULL
m <- model.matrix(formula, data)
y <- matrix(data[,as.character(formula)[2]], ncol=1)
y <- y[rownames(m),, drop=FALSE]
head(m)
y <- y[as.numeric(rownames(m)),, drop=FALSE]
dim(m)
head(y)
length(y)
svd_obj <- svd(m)
u <- svd_obj$u
v <- svd_obj$v
svals <- svd_obj$d
D <- diag(svals / (svals^2 + lambda))
beta <-V %*% D %*% t(U) %*% y
svd_obj <- svd(m)
u <- svd_obj$u
v <- svd_obj$v
svals <- svd_obj$d
D <- diag(svals / (svals^2 + lambda))
beta <-V %*% D %*% t(U) %*% y
V
D
dim(V)
dim(D)
rownames(data) <- NULL
m <- model.matrix(formula, data)
y <- matrix(data[,as.character(formula)[2]], ncol=1)
y <- y[as.numeric(rownames(m)),, drop=FALSE]
svd_obj <- svd(m)
u <- svd_obj$u
v <- svd_obj$v
svals <- svd_obj$d
D <- diag(svals / (svals^2 + lambda))
beta <-V %*% D %*% t(U) %*% y
svals / (svals^2 + lambda)
dim(m)
dim(u)
dim(v)
length(svals)
beta <-v %*% D %*% t(U) %*% y
v
dim(v)
v %*% D
beta <-v %*% D %*% t(U) %*% y
svd_obj <- svd(m)
U <- svd_obj$u
V <- svd_obj$v
svals <- svd_obj$d
D <- diag(svals / (svals^2 + lambda))
beta <-V %*% D %*% t(U) %*% y
rownames(beta) <- colnames(m)
ret <- list(coefficients = beta, lambda = lambda, form = form)
class(ret) <- "ridge_reg"
ret
fit_lm.ridge <- MASS::lm.ridge(y ~., ridge_train, lambda = 1.2121212)
#' @description This function passes parameters to the lm function.
#' @param formula a formula
#' @param data a data.frame
#' @param lambda a numeric parameter
#' @return An ridge_reg object
#' @importFrom stats
#' @examples
#' fit <- ridge_reg(Sepal.Length ~., iris, 1.2)
#' summary(fit)
#' @export
ridge_reg <- function(formula, data, lambda) {
rownames(data) <- NULL
m <- model.matrix(formula, data)
y <- matrix(data[,as.character(formula)[2]], ncol=1)
y <- y[as.numeric(rownames(m)),, drop=FALSE]
svd_obj <- svd(m)
U <- svd_obj$u
V <- svd_obj$v
svals <- svd_obj$d
D <- diag(svals / (svals^2 + lambda))
beta <-V %*% D %*% t(U) %*% y
rownames(beta) <- colnames(m)
ret <- list(coefficients = beta, lambda = lambda, form = form)
class(ret) <- "ridge_reg"
ret
}
fit_ridge <- ridge_reg(y ~., ridge_train)
fit_ridge <- ridge_reg(y ~., ridge_train, lambda = 1.2121212)
fit_ridge
fit_lm.ridge
fit_ridge$coef
fit_lm.ridge$coef
summary(fit_lm.ridge)
# Using Baysien
beta <- solve(crossprod(m) + diag(lambda,ncol(m), crossprod(m, y)))
m
crossprod(m)
solve(crossprod(m) + diag(lambda, ncol(m)), crossprod(m, y))
lambda=1.2121212
# Using Baysien
beta <- solve(crossprod(m) + diag(lambda,ncol(m)), crossprod(m, y)))
solve(crossprod(m) + diag(lambda, ncol(m)), crossprod(m, y))
fit_lm.ridge$coef
mvrnorm(n = n, mu = c(0, 0), Sigma = diag(1,2))
head(m)
# Using Baysien
beta <- solve(crossprod(m[-1]) + diag(lambda, ncol(m[-1])), crossprod(m[-1], y))
ncol(m[-1])
# Using Baysien
beta <- solve(crossprod(m[,-1]) + diag(lambda, ncol(m[,-1])), crossprod(m[,-1], y))
beta
fit_lm.ridge
k=2-
)
k=30
# Principle Component
svd_obj <- svd(m)
U <- svd_obj$u
V <- svd_obj$v
dvals <- rep(0, ncol(X))
dvals[seq_len(k)] <- 1 / svd_obj[["d"]][seq_len(k)]
dvals <- rep(0, ncol(m))
dvals[seq_len(k)] <- 1 / svd_obj[["d"]][seq_len(k)]
D <- diag(dvals)
beta <- V %*% D %*% t(U) %*% y
dim(V)
dim(D
)
k=5
dvals[seq_len(k)] <- 1 / svd_obj[["d"]][seq_len(k)]
D <- diag(dvals)
beta <- V %*% D %*% t(U) %*% y
U <- svd_obj$u
V <- svd_obj$v
dvals <- rep(0, ncol(m))
dvals[seq_len(k)] <- 1 / svd_obj[["d"]][seq_len(k)]
D <- diag(dvals)
beta <- V %*% D %*% t(U) %*% y
beta
fit_lm.ridge
svd_obj <- svd(m)
U <- svd_obj$u
V <- svd_obj$v
svals <- svd_obj$d
D <- diag(svals / (svals^2 + lambda))
beta <-V %*% D %*% t(U) %*% y
rownames(beta) <- colnames(m)
beta
1.80152822 - 1.78814106
fit_lm.ridge$scales
test()
test()
beta
fit_lm.ridge$coef
k <- ncol(m)
beta
beta[1:(k-1)]
beta[1:(k-1), drop=FALSE]
coef
coef <- beta[1:(k-1)]
coef
names(coef) <- colnames(m[,-1])
coef
test()
fit_lm.ridge$coef
coef
beta
beta[-k]
k
coef <- beta[2:k]
names(coef) <- colnames(m[,-1])
coef
test()
test()
test()
9.54 + 15.9 + 8.5 + 4.02 + 18.19 + 28.57 + 21.49 + 9.99 + 17.98
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(gapminder)
library(rbokeh)
data(iris)
g <- ggplot(iris,
aes(x = Sepal.Length, y = Sepal.Width, color = Species,
shape = Species)) + geom_point()
library(ggplot2)
library(gapminder)
library(rbokeh)
data(iris)
g <- ggplot(iris,
aes(x = Sepal.Length, y = Sepal.Width, color = Species,
shape = Species)) + geom_point()
g
library(dplyr)
p <- figure() %>%
ly_points(Sepal.Length, Sepal.Width, data = iris,
color = Species, glyph = Species,
hover = list(Sepal.Length, Sepal.Width))
p
?ly_points
p
?ly_points
p
?gapreminder
library(ggplot2)
library(gapminder)
library(rbokeh)
library(dplyr)
?gapreminder
?gapminder
gapminder[gapminder$country == "Isreal", ]
gapminder[gapminder$country == "Isreal", ] %>%
figure()
library(tidyr)
a <- gapminder %>% nest(-country)
a
?gapminder
gc <- gapminder %>% nest(-country)
# Population change over time.
gapminder[gapminder$country == "Israel", ] %>%
figure() %>% ly_lines(x = year, y = pop)
gc$data[[1]]
library(purrr)
?purrr
gc <- gapminder %>% nest(-country) %>% mutate(first_year = map_dbl(data, function(x) min(x$year)))
gc
gc$data[[1]]
gc$first_year
?map2_dbl
# minus country: country is the only thing not nested
# make a new column called first_year
gc
?lowess
library(trelliscope)
library(trelliscopejs)
make_viz <- function(x) {
fit <- lowess(x$year, x$pop)
figure() %>%
ly_points(year, pop, data = x)%>%
ly_lines(fit)
}
gc <- gapminder %>%
nest(-country) %>%
mutate(first_year = map_dbl(data, function(x) min(x$year))) %>%
mutate(pop_fit = map(data, make_viz))
# minus country: country is the only thing not nested
# make a new column called first_year
gc
gc %>% trelliscope(name = "GapMinder", panel_cols = "pop_fit")
gc %>% trelliscope(name = "GapMinder", panel_col = "pop_fit")
lowess_max_diff <- function(x) {
fit <- lowess(x$year, x$pop)
max(abs(x$pop - fit$y))
}
gc <- gapminder %>%
nest(-country) %>%
mutate(lmd = map_dbl(data, lowess_max_diff)) %>%
mutate(first_year = map_dbl(data, function(x) min(x$year))) %>%
mutate(pop_fit = map(data, make_viz))
gc
gc %>% trelliscope(name = "GapMinder", panel_col = "pop_fit")
plot(zs, ds)
lines(zs,d2s)
plot(zs, ds, lwd=1)
lines(zs,d2s, lwd=1)
plot(zs, ds, lty=1, lwd=1)
lines(zs,d2s, lty=1, lwd=1)
plot(zs, ds, lty=1, lwd=1)
plot(zs, ds, lty=1, lwd=0.5)
plot(zs, ds, lty=1, lwd=0.1)
?plot
plot(zs, ds, type="l")
lines(zs,d2s)
?plot
x <- c(1,2,3)
y <- c(2,3,4)
plot(x,y)
plot(x,y, type="b")
plot(x,y, type="b", xaxt="n")
plot(x,y, type="b")
plot(x,y, type="b", xaxt="n")
plot(x,y, type="b", xaxt="n", axis.lty=1)
plot(x,y, type="b", xaxt="n", lty=1)
plot(x,y, type="b", xaxt="n", lty=2)
?axis
?qnorm
?dbinom
(qnorm(0.975)+ qnorm(0.9))^2
(1-0.8051)*2
(1-pnorm(0.15))*2
pnorm(0.8)
qnorm(0.8)
2*(1-pnorm(1.645))
qnorm(0.9)
qnorm(0.5)
qnorm(0.3)
(1 - pnorm(1.10))*2
(1 - pnorm(0.84))*2
(1 - pnorm(1.56))*2
sqrt(2*(2.17+1.28)^2 * 6.45 / 34)
68/0.8^2
(0.9*0.1+0.65*0.35)/0.25^2
(0.9*0.1+0.65*0.35)/0.25^2*(1-qnorm(0.99)+qnorm(0.93))^2
((0.9*0.1+0.65*0.35)/0.25^2)*(1-qnorm(0.99)+qnorm(0.93))^2
((0.9*0.1+0.65*0.35)/0.25^2)*(qnorm(0.99)+qnorm(0.93))^2
pnorm(19.67)
1.96*sqrt(2)*3/0.02
1.96*sqrt(2)*sqrt(3/100)/0.02
24……2
24^2
setwd("~/Documents/Master2-2/BIS 557-Computational Statistics/homework 1/bis557")
setwd("~/Documents/Master2-2/BIS 557-Computational Statistics/homework 1/bis557")
check()
check()
locale
check()
