arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c[, c("i", "j", "x")]
}
a <- data.frame(i = c(1, 2), j = c(1, 1), x = c(3, 1))
b <- data.frame(i = c(1, 2, 2), j = c(1, 1, 2), x = c(4.4, 1.2, 3))
sparse_multiply(a, b)
setMethod("%*%", "sparse.matrix", `%*%.sparse.matrix`)
rm("%*%.sparse.matrix")
setMethod("%*%", "sparse.matrix", function(a,b) {a+b})
setMethod("%*%", signature = (x = "sparse.matrix",y = "sparse.matrix"), function(a,b) {a+b})
?setMethod
setMethod("%*%", signature = character(x = "sparse.matrix",y = "sparse.matrix"), function(a,b) {a+b})
setMethod("%*%", signature(x = "sparse.matrix",y = "sparse.matrix"), function(a,b) {a+b})
setMethod("%*%", signature(x = "sparse.matrix",y = "sparse.matrix"), function(x,y) {x+y})
setMethod("%*%", signature(x = "sparse.matrix",y = "sparse.matrix"), function(x,y) {
if (!inherits(y, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(x$j, "label") != attr(y$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(x$i, "label") == 0 || attr(x$j, "label") == 0 ||
attr(y$i, "label") == 0 || attr(y$j, "label") == 0) {
arow <- max(x$i); acol <- max(x$j)
brow <- max(y$i); bcol <- max(y$j)
} else {
arow <- attr(x$i, "label"); acol <- attr(x$j, "label")
brow <- attr(y$i, "label"); bcol <- attr(y$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, x, by = c("i", "j"), all.x = TRUE)
c <- merge(c, y, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
})
test_that("We can multiply and transpose", {
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
expect_error(sm1 %*% sm1)
expect_equal(t(sm1) %*% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
})
methods("%*%")
rm("%*%.sparse.matrix")
rm('%*%.sparse.matrix')
rm(`%*%.sparse.matrix``)
)
``
rm(`%*%.sparse.matrix`)
methods("%*%")
remove("%*%.sparse.matrix")
setClass("sparse.matrix")
setMethod("%*%", signature(x = "sparse.matrix",y = "sparse.matrix"), function(x,y) {
if (!inherits(y, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(x$j, "label") != attr(y$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(x$i, "label") == 0 || attr(x$j, "label") == 0 ||
attr(y$i, "label") == 0 || attr(y$j, "label") == 0) {
arow <- max(x$i); acol <- max(x$j)
brow <- max(y$i); bcol <- max(y$j)
} else {
arow <- attr(x$i, "label"); acol <- attr(x$j, "label")
brow <- attr(y$i, "label"); bcol <- attr(y$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, x, by = c("i", "j"), all.x = TRUE)
c <- merge(c, y, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
})
test_that("We can multiply and transpose", {
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
expect_error(sm1 %*% sm1)
expect_equal(t(sm1) %*% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
})
library(testthat)
context('Test the sparse matrix functions')
# If no dimensions are given, assume the largest coordinates are the
# dimensions.
sm0 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(1, 1))
sm1 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(3, 1), dims = c(3, 2))
sm2 <- sparse.matrix(i = c(1, 2, 2), j = c(1, 1, 2), x = c(4.4, 1.2, 3),
dims = c(2, 3))
sm3 <- sparse.matrix(i = rep(1, 3), j = 1:3, x = 1:3, dims = c(2, 3))
test_that("We can multiply and transpose", {
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
expect_error(sm1 %*% sm1)
expect_equal(t(sm1) %*% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
})
sm1 %*% sm3
setMethod("%*%", signature(x = "sparse.matrix",y = "sparse.matrix"), function(x,y) {
if (!inherits(y, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(x$j, "label") != attr(y$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(x$i, "label") == 0 || attr(x$j, "label") == 0 ||
attr(y$i, "label") == 0 || attr(y$j, "label") == 0) {
arow <- max(x$i); acol <- max(x$j)
brow <- max(y$i); bcol <- max(y$j)
} else {
arow <- attr(x$i, "label"); acol <- attr(x$j, "label")
brow <- attr(y$i, "label"); bcol <- attr(y$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, x, by = c("i", "j"), all.x = TRUE)
c <- merge(c, y, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(x$i, "label"), attr(y$j, "label")))
})
sm1 %*% sm3
setClass("sparse.matrix")
setMethod("%*%", signature(x = "sparse.matrix",y = "sparse.matrix"), function(x,y) {
if (!inherits(y, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(x$j, "label") != attr(y$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(x$i, "label") == 0 || attr(x$j, "label") == 0 ||
attr(y$i, "label") == 0 || attr(y$j, "label") == 0) {
arow <- max(x$i); acol <- max(x$j)
brow <- max(y$i); bcol <- max(y$j)
} else {
arow <- attr(x$i, "label"); acol <- attr(x$j, "label")
brow <- attr(y$i, "label"); bcol <- attr(y$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, x, by = c("i", "j"), all.x = TRUE)
c <- merge(c, y, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(x$i, "label"), attr(y$j, "label")))
})
sm1 %*% sm3
setClass("sparse.matrix")
setMethod("%*%", signature(a = "sparse.matrix",b = "sparse.matrix"), function(a,b) {
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
#sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
})
setClass("sparse.matrix")
setMethod("%*%", signature("sparse.matrix"), function(a,b) {
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
#sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
})
setClass("sparse.matrix")
setMethod("%*%", signature("sparse.matrix","sparse.matrix"), function(a,b) {
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
#sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
})
setMethod("%*%", signature("sparse.matrix","sparse.matrix"), function(a,b) {a})
setMethod("%*%", signature(a="sparse.matrix",b="sparse.matrix"), function(a,b) {a})
setMethod("%*%", signature(x="sparse.matrix",y="sparse.matrix"), function(x,y) {x})
sm1
sm2
sm1 %*% sm2
`%A%.sparse.matrix` <- function(a,b) {
#UseMethod("%*%", a)
# Check the type of b
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
}
test_that("We can multiply and transpose", {
expect_equal(sm1 %A% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
expect_error(sm1 %A% sm1)
expect_equal(t(sm1) %A% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
})
`%A%.sparse.matrix` <- function(a,b) {
#UseMethod("%*%", a)
# Check the type of b
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
}
test_that("We can multiply and transpose", {
expect_equal(sm1 %A% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
expect_error(sm1 %A% sm1)
expect_equal(t(sm1) %A% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
})
sm1 %A% sm3
sparse.matrix <- function(i, j, x, dims=NULL) {
sm <- data.frame(i=i, j=j, x=x)
# If no dimensions are given, assume the largest coordinates are the dimensions.
if (is.null(dims)) {
dims <- c(max(i), max(j))
}
r <- dims[1]; c <- dims[2]
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
sm <- merge(index, sm, by = c("i", "j"), all.x = TRUE, sort=FALSE)
sm <- sm[sm$x != 0 & !is.na(sm$x),]
attr(sm$i, "label") <- r
attr(sm$j, "label") <- c
class(sm) <- c("sparse.matrix", class(sm))
sm
}
`+.sparse.matrix` <- function(a,b) {
# Check whether the dimensions of a and b agree
if (attr(a$i, "label") != attr(b$i, "label") ||
attr(a$j, "label") != attr(b$j, "label")) {
stop('The dimensions of the two input matrix do not match')
}
c <- merge(a, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
c$x <- c$x1 + c$x2
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x)
}
t.sparse.matrix <- function(a) {
# swap i and j index
ta <- a
names(ta) <- c('j', 'i', 'x')
ta <- ta[,c('i', 'j', 'x')]
r <- attr(ta$i, "label"); c <- attr(ta$j, "label")
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
ta <- merge(index, ta, by = c("i", "j"), all.x = TRUE, sort=FALSE)
ta <- ta[ta$x != 0 & !is.na(ta$x),]
sparse.matrix(i=ta$i, j=ta$j, x=ta$x, dim=c(r,c))
}
`%A%.sparse.matrix` <- function(a,b) {
#UseMethod("%*%", a)
# Check the type of b
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
}
sm1 %A% sm3
`A.sparse.matrix` <- function(a,b) {
#UseMethod("%*%", a)
# Check the type of b
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
}
sm1 A sm3
sm1 `A`` sm3
sm1 `A` sm3
sm0 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(1, 1))
sm1 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(3, 1), dims = c(3, 2))
sm2 <- sparse.matrix(i = c(1, 2, 2), j = c(1, 1, 2), x = c(4.4, 1.2, 3),
dims = c(2, 3))
sm3 <- sparse.matrix(i = rep(1, 3), j = 1:3, x = 1:3, dims = c(2, 3))
sm1 %A% sm3
sm1 `%A%`` sm3
sm1 `%A%` sm3
