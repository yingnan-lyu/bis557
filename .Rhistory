format(mydate, '%D %A %b %y')
format(mydate, '%D %a %B %Y')
?format
c(1,"a")
?kmeans
?glm
dat
names(cryingdata) <- "name"
head(cryingdata)
?try
?vif
?vif
vif()
?try
?ts
my <- ts(Sales, frequency=12, start=c(2000, 4))
as.Date("2018-02-03", origin = "1970-01-01")
as.Date("2018-02-03", origin = "1970-01-01") - as.Date("2018-01-01", origin="1970-01-01")
class(as.Date("2018-02-03", origin = "1970-01-01") - as.Date("2018-01-01", origin="1970-01-01"))
cryingdata[,"crying"]
dat
dat$y
dat[['y']]
?sqldf
plot(c(1,2,3))
library(tidyr)
?gather
?spread
library(dplyr)
?mutate
?transmutate
?regexpr
regexpr("a+", c("dear", "hello", "oh dear", "aaha"), perl=TRUE)
?filter
fit <- lm(cryingdata[,1]~cryingdata[,2])
summary(fit)
coefficients(fit)
?IQR
myfunct <- function(x) {function(z) Reduce(function(y, a) x,z)}
fn <- myfunct(c(function(x) x+1, function(x) x*x))
fn(3)
c <- 15
myfunc <- function(a) {
newfunc <- function(b) {
a+c
}
c <-5
a+newfunc(a)
}
myfunc(5)
paste("a", "b")
paste("a", "b", sep="")
library(car)
install.packages("car")
library(car)
?vif
fit
myvifs <- try(vif(fit), silient=TRUE
)
myvifs <- try(vif(fit), silent = TRUE)
class(myvifs)
myvifs
install.packages(keras)
install.packages("keras")
knitr::opts_chunk$set(echo = TRUE)
library(keras)
# The data,
mnist <- datasets_minist()
# The data,
mnist <- dataset_minist()
# The data,
mnist <- dataset_mnist()
library(keras)
# The data,
mnist <- dataset_mnist()
x_train <- mnist$train$x
library(keras)
# The data,
mnist <- dataset_mnist()
setwd("~/Documents/Master2-2/BIS 557-Computational Statistics/bis557")
library(devtools)
test()
check()
7000*(64/139)
7000*(64/139) -64
21、64
(32-21)/32
32/12
21/6
(32-21)/32
(32-21)/21
?axis
?mtext
1e-14
p <- c(0.5, 1e-14, 1e-14)
p
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
# Define X and p
X <- matrix(c(1,2,3,
1,2,5), nrow=3, byrow=TRUE)
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
# Check Hessian with logistic variation
var <- diag(p*(1-p))
var
H <- t(X) %*% var %*% X
solve(H)
solve(var)
p <- c(0.5, 0.0000001, 0.0000001)
p
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
# Check Hessian with logistic variation
var <- diag(p*(1-p))
var
H <- t(X) %*% var %*% X
solve(H)
p <- c(0.5, 0.99999, 0.99999)
p
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
# Check Hessian with logistic variation
var <- diag(p*(1-p))
var
H <- t(X) %*% var %*% X
solve(H)
p <- c(0.5, 0.5, 0.99999)
p
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
# Check Hessian with logistic variation
var <- diag(p*(1-p))
var
H <- t(X) %*% var %*% X
solve(H)
# Define X and p
X <- matrix(c(1,2,3,
1,2,5), nrow=3, byrow=TRUE)
X
p <- c(1,1,1)
p <- c(0.5, 0.5, 0.99999)
p
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
# Check Hessian with logistic variation
var <- diag(p*(1-p))
var
H <- t(X) %*% var %*% X
# solve(H) # This line gives an error due to singularity
solve(H)
p <- c(0.99999, 0.99999, 0.99999)
p
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
# Check Hessian with logistic variation
var <- diag(p*(1-p))
var
H <- t(X) %*% var %*% X
solve(H)
solve(matrix(c(4.1, 2.8, 9.676, 6.608), nrow=2, byrow=2))
solve(matrix(c(4.1, 2.8, 9.676, 6.608), nrow=2, byrow=T))
X <- matrix(c(1,2,
1,5), nrow=2, byrow=TRUE)
X
p <- c(0.5, 0.99999)
p
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
X <- matrix(c(1,2,
1,5), nrow=2, byrow=TRUE)
X
p <- c(0.5, 0.99999)
p
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
# Check Hessian with logistic variation
var <- diag(p*(1-p))
var
H <- t(X) %*% var %*% X
solve(H)
H %*% solve(H)
var
var <- diag(c(0.5, 0.99))
var
H <- t(X) %*% var %*% X
solve(H)
H %*% solve(H)
X <- matrix(c(1,2,3,
1,2,5), nrow=3, byrow=TRUE)
X
p <- c(1,1,1)
p
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
# Check Hessian with logistic variation
var <- diag(p*(1-p))
var
H <- t(X) %*% var %*% X
(32-21)/32
(64-21)/64
(64-42)/64
# Define X and p
X <- matrix(c(1,2,3,
1,2,5), nrow=3, byrow=TRUE)
X
# Define X and p
X <- matrix(c(1,2,3,
1,2,5), nrow=3, byrow=TRUE)
X
p <- c(1,1,1)
p
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
# Check Hessian with logistic variation
var <- diag(p*(1-p))
var
H <- t(X) %*% var %*% X
# solve(H) # This line gives an error due to singularity
X <- matrix(c(1,2,3,
1,2,5), nrow=3, byrow=TRUE)
X
p <- c(1,1,1)
p
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
# Check Hessian with logistic variation
var <- diag(p*(1-p))
var
H <- t(X) %*% var %*% X
solve(H)
p <- c(0.99999999999,0.9999999999,0.9999999999)
p
# Show linear Hessian is well-conditioned
solve(t(X) %*% X)
# Check Hessian with logistic variation
var <- diag(p*(1-p))
var
H <- t(X) %*% var %*% X
solve(H)
H %*% solve(H)
check()
check()
check()
check()
a
sm0 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(1, 1))
sm1 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(3, 1), dims = c(3, 2))
sm2 <- sparse.matrix(i = c(1, 2, 2), j = c(1, 1, 2), x = c(4.4, 1.2, 3),
dims = c(2, 3))
sm3 <- sparse.matrix(i = rep(1, 3), j = 1:3, x = 1:3, dims = c(2, 3))
a=sm1
# Define function t to transpose sparse matrix
t.sparse.matrix <- function(a) {
# swap i and j index
ta <- a
names(ta) <- c('j', 'i', 'x')
ta <- ta[,c('i', 'j', 'x')]
r <- attr(ta$i, "label"); c <- attr(ta$j, "label")
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
ta <- merge(index, ta, by = c("i", "j"), all.x = TRUE, sort=FALSE)
ta <- ta[ta$x != 0 & !is.na(ta$x),]
#sparse.matrix(i=ta$i, j=ta$j, x=ta$x, dim=c(r,c))
sm <- data.frame(i=ta$i, j=ta$j, x=ta$x)
dims <- c(r, c)
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
sm <- merge(index, sm, by = c("i", "j"), all.x = TRUE, sort=FALSE)
sm <- sm[sm$x != 0 & !is.na(sm$x),]
attr(sm$i, "label") <- r
attr(sm$j, "label") <- c
class(sm) <- c("sparse.matrix", class(sm))
sm
}
t(sm1)
sm1
t(sm1) %*% sm1
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2))
`%*%.default` = .Primitive("%*%")
`%*%` = function(x,...){
UseMethod("%*%",x)
}
`%*%` <- function(x, y) {
UseMethod("%*%", x)
}
`%*%.sparse.matrix` <- function(a,b) {
#UseMethod("%*%", a)
# Check the type of b
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
#sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
sm <- data.frame(i=c$i, j=c$j, x=c$x)
dims <- c(attr(a$i, "label"), attr(b$j, "label"))
r <- dims[1]; c <- dims[2]
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
sm <- merge(index, sm, by = c("i", "j"), all.x = TRUE, sort=FALSE)
sm <- sm[sm$x != 0 & !is.na(sm$x),]
attr(sm$i, "label") <- r
attr(sm$j, "label") <- c
class(sm) <- c("sparse.matrix", class(sm))
sm
}
sm1 %*% sm1
t(sm1) %*% sm1
check()
?`%*%`
?`+`
check()
check()
`+.sparse.matrix` <- function(a,b) {
# Check whether the dimensions of a and b agree
if (attr(a$i, "label") != attr(b$i, "label") ||
attr(a$j, "label") != attr(b$j, "label")) {
stop('The dimensions of the two input matrix do not match')
}
c <- merge(a, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
c$x <- c$x1 + c$x2
c <- c[, c("i", "j", "x")]
#sparse.matrix(i=c$i, j=c$j, x=c$x)
sm <- data.frame(i=c$i, j=c$j, x=c$x)
dims <- c(attr(a$i, "label"), attr(a$j, "label"))
r <- dims[1]; c <- dims[2]
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
sm <- merge(index, sm, by = c("i", "j"), all.x = TRUE, sort=FALSE)
sm <- sm[sm$x != 0 & !is.na(sm$x),]
attr(sm$i, "label") <- r
attr(sm$j, "label") <- c
class(sm) <- c("sparse.matrix", class(sm))
sm
}
sm0 + sm0
sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(2, 2),
dims = c(2, 1))
check()
# Define a function to generate sparse matrix
sparse.matrix <- function(i, j, x, dims=NULL) {
sm <- data.frame(i=i, j=j, x=x)
# If no dimensions are given, assume the largest coordinates are the dimensions.
if (is.null(dims)) {
dims <- c(max(i), max(j))
}
r <- dims[1]; c <- dims[2]
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
sm <- merge(index, sm, by = c("i", "j"), all.x = TRUE, sort=FALSE)
sm <- sm[sm$x != 0 & !is.na(sm$x),]
attr(sm$i, "label") <- r
attr(sm$j, "label") <- c
class(sm) <- c("sparse.matrix", class(sm))
sm
}
# Define function + to add sparse matrix
`+.sparse.matrix` <- function(a,b) {
# Check whether the dimensions of a and b agree
if (attr(a$i, "label") != attr(b$i, "label") ||
attr(a$j, "label") != attr(b$j, "label")) {
stop('The dimensions of the two input matrix do not match')
}
c <- merge(a, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
c$x <- c$x1 + c$x2
c <- c[, c("i", "j", "x")]
#sparse.matrix(i=c$i, j=c$j, x=c$x)
sm <- data.frame(i=c$i, j=c$j, x=c$x)
dims <- c(attr(a$i, "label"), attr(a$j, "label"))
r <- dims[1]; c <- dims[2]
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
sm <- merge(index, sm, by = c("i", "j"), all.x = TRUE, sort=FALSE)
sm <- sm[sm$x != 0 & !is.na(sm$x),]
attr(sm$i, "label") <- r
attr(sm$j, "label") <- c
class(sm) <- c("sparse.matrix", class(sm))
sm
}
# Define function t to transpose sparse matrix
t.sparse.matrix <- function(a) {
# swap i and j index
ta <- a
names(ta) <- c('j', 'i', 'x')
ta <- ta[,c('i', 'j', 'x')]
r <- attr(ta$i, "label"); c <- attr(ta$j, "label")
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
ta <- merge(index, ta, by = c("i", "j"), all.x = TRUE, sort=FALSE)
ta <- ta[ta$x != 0 & !is.na(ta$x),]
#sparse.matrix(i=ta$i, j=ta$j, x=ta$x, dim=c(r,c))
sm <- data.frame(i=ta$i, j=ta$j, x=ta$x)
dims <- c(r, c)
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
sm <- merge(index, sm, by = c("i", "j"), all.x = TRUE, sort=FALSE)
sm <- sm[sm$x != 0 & !is.na(sm$x),]
attr(sm$i, "label") <- r
attr(sm$j, "label") <- c
class(sm) <- c("sparse.matrix", class(sm))
sm
}
# Define a function %*% to multiply sparse matrix
`%*%.default` = .Primitive("%*%")
`%*%` = function(x,...){
UseMethod("%*%",x)
}
`%*%` <- function(x, y) {
UseMethod("%*%", x)
}
`%*%.sparse.matrix` <- function(a,b) {
#UseMethod("%*%", a)
# Check the type of b
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
#sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
sm <- data.frame(i=c$i, j=c$j, x=c$x)
dims <- c(attr(a$i, "label"), attr(b$j, "label"))
r <- dims[1]; c <- dims[2]
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
sm <- merge(index, sm, by = c("i", "j"), all.x = TRUE, sort=FALSE)
sm <- sm[sm$x != 0 & !is.na(sm$x),]
attr(sm$i, "label") <- r
attr(sm$j, "label") <- c
class(sm) <- c("sparse.matrix", class(sm))
sm
}
library(testthat)
context('Test the sparse matrix functions')
# If no dimensions are given, assume the largest coordinates are the
# dimensions.
sm0 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(1, 1))
sm1 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(3, 1), dims = c(3, 2))
sm2 <- sparse.matrix(i = c(1, 2, 2), j = c(1, 1, 2), x = c(4.4, 1.2, 3),
dims = c(2, 3))
sm3 <- sparse.matrix(i = rep(1, 3), j = 1:3, x = 1:3, dims = c(2, 3))
test_that("We have sparse.matrix objects.", {
expect_is(sm0, "sparse.matrix")
expect_is(sm1, "sparse.matrix")
expect_is(sm2, "sparse.matrix")
})
test_that("We can add sparse matrices.", {
expect_equal(sm0 + sm0,
sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(2, 2),
dims = c(2, 1)))
expect_equal(sm2 + sm3,
sparse.matrix(i = c(rep(1:2, 2), 1), j = c(1, 1, 2, 2, 3),
x = c(5.4, 1.2, 2, 3, 3)))
expect_error(sm2 + sm0)
})
test_that("We can multiply and transpose", {
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
expect_error(sm1 %*% sm1)
expect_equal(t(sm1) %*% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
})
test()
?T
?t
check()
check()
sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(1, 1))
