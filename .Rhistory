index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
a
a <- sparse.matrix(i=a@i, j=a@j, x=a@x, dim=a@dims)
class(a)
b <- sparse.matrix(i=b@i, j=b@j, x=b@x, dim=b@dims)
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
arow
brow
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
setMethod("%*%", signature(a="sparse.matrix", b="sparse.matrix"),
function(a,b) {
#UseMethod("%*%", a)
a <- sparse.matrix(i=a@i, j=a@j, x=a@x, dim=a@dims)
b <- sparse.matrix(i=b@i, j=b@j, x=b@x, dim=b@dims)
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
})
setMethod("%*%", signature("sparse.matrix", "sparse.matrix"),
function(a,b) {
#UseMethod("%*%", a)
a <- sparse.matrix(i=a@i, j=a@j, x=a@x, dim=a@dims)
b <- sparse.matrix(i=b@i, j=b@j, x=b@x, dim=b@dims)
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
})
setMethod("%*%",
function(a,b) {
#UseMethod("%*%", a)
a <- sparse.matrix(i=a@i, j=a@j, x=a@x, dim=a@dims)
b <- sparse.matrix(i=b@i, j=b@j, x=b@x, dim=b@dims)
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
})
setMethod("%*%", "sparse.matrix"
function(a,b) {
setMethod("%*%", "sparse.matrix",
function(a,b) {
#UseMethod("%*%", a)
a <- sparse.matrix(i=a@i, j=a@j, x=a@x, dim=a@dims)
b <- sparse.matrix(i=b@i, j=b@j, x=b@x, dim=b@dims)
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
})
?setMethod
setMethod("%*%", signature(a="sparse.matrix", b="sparse.matrix"),
function(a,b) {
#UseMethod("%*%", a)
a <- sparse.matrix(i=a@i, j=a@j, x=a@x, dim=a@dims)
b <- sparse.matrix(i=b@i, j=b@j, x=b@x, dim=b@dims)
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
})
setMethod("%*%", signature(first="sparse.matrix", second="sparse.matrix"),
function(first,second) {
#UseMethod("%*%", a)
a <- sparse.matrix(i=first@i, j=first@j, x=first@x, dim=first@dims)
b <- sparse.matrix(i=second@i, j=second@j, x=second@x, dim=second@dims)
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
})
setMethod("%*%", signature(first="sparse.matrix", second="sparse.matrix"),
function(first,second) {print(first)})
setMethod("%*%", signature(FirstArg="sparse.matrix", SecondArg="sparse.matrix"),
function(FirstArg,SecondArg) {print(SecondArg)})
setMethod("%*%", signature(object="sparse.matrix"),
function(object) {print(object)})
setMethod("%*%", "sparse.matrix",
function(object) {print(object)})
setclass("sparse.matrix")
setClass("sparse.matrix")
setMethod("%*%", "sparse.matrix",
function(object) {print(object)})
Q
knitr::opts_chunk$set(echo = TRUE)
# Simulate 10000 paths of length 100 of Fred
set.seed(1)
P <- matrix(c(0,1,0,.2,0,.8,.1,.3,.6), nrow=3, byrow=TRUE)
Q <- matrix(c(0,1,-1,-1,0,1,1,-1,0), nrow=3, byrow=TRUE)
npath <- 10000
nstep <- 100
paths <- matrix(0, npath, nstep)
clockwise <- matrix(0, npath, nstep)
nstate <- nrow(P)
for (i in 1:npath) {
x0 <- 1
paths[i,1] <- x0
for (j in 2:nstep) {
x <- sample(1:nstate, 1, prob = P[x0,])
paths[i,j] <- x
clockwise[i,j] <- Q[x0,x]
x0 <- x
}
}
# Store and plot clockwise movement amount
netclockwise <- rowSums(clockwise)
plot(table(netclockwise))
Q
P
dim(clockwise)
sum(clockwise[1,])
netclockwise[1]
i=1
j=1
x0 <- 1
paths[i,1] <- x0
1:nstate
P[x0,]
x <- sample(1:nstate, 1, prob = P[x0,])
x
paths[i,j] <- x
Q[x0,x]
Q
x0 <- x
x0
P[x0,]
x <- sample(1:nstate, 1, prob = P[x0,])
x
x <- sample(1:nstate, 1, prob = P[x0,])
x
x <- sample(1:nstate, 1, prob = P[x0,])
x
paths[i,j] <- x
Q[x0,x]
Q
x0 <- x
nrow(mediation)
setwd("~/Documents/Master2-2/S&DS 538-Probability and Statistics/Final Take-Home")
mediation <- read.csv("mediation-data_Wright-London.csv")
nrow(mediation)
`%*%.default` = .Primitive("%*%")
`%*%` = function(x,...){
UseMethod("%*%",x)
}
`%*%` <- function(x, y) {
UseMethod("%*%", x)
}
`%*%.sparse.matrix` <- function(a,b) {
#UseMethod("%*%", a)
# Check the type of b
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
}
test_that("We can multiply and transpose", {
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
expect_error(sm1 %*% sm1)
expect_equal(t(sm1) %*% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
})
library(testthat)
sm0 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(1, 1))
sm1 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(3, 1), dims = c(3, 2))
sm2 <- sparse.matrix(i = c(1, 2, 2), j = c(1, 1, 2), x = c(4.4, 1.2, 3),
dims = c(2, 3))
sm3 <- sparse.matrix(i = rep(1, 3), j = 1:3, x = 1:3, dims = c(2, 3))
test_that("We can multiply and transpose", {
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
expect_error(sm1 %*% sm1)
expect_equal(t(sm1) %*% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
})
test()
# Define a function to generate sparse matrix
sparse.matrix <- function(i, j, x, dims=NULL) {
sm <- data.frame(i=i, j=j, x=x)
# If no dimensions are given, assume the largest coordinates are the dimensions.
if (is.null(dims)) {
dims <- c(max(i), max(j))
}
r <- dims[1]; c <- dims[2]
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
sm <- merge(index, sm, by = c("i", "j"), all.x = TRUE, sort=FALSE)
sm <- sm[sm$x != 0 & !is.na(sm$x),]
attr(sm$i, "label") <- r
attr(sm$j, "label") <- c
class(sm) <- c("sparse.matrix", class(sm))
sm
}
# Define function + to add sparse matrix
`+.sparse.matrix` <- function(a,b) {
# Check whether the dimensions of a and b agree
if (attr(a$i, "label") != attr(b$i, "label") ||
attr(a$j, "label") != attr(b$j, "label")) {
stop('The dimensions of the two input matrix do not match')
}
c <- merge(a, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
c$x <- c$x1 + c$x2
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x)
}
# Define function t to transpose sparse matrix
t.sparse.matrix <- function(a) {
# swap i and j index
ta <- a
names(ta) <- c('j', 'i', 'x')
ta <- ta[,c('i', 'j', 'x')]
r <- attr(ta$i, "label"); c <- attr(ta$j, "label")
index <- data.frame(i=rep(1:r), j=rep(1:c, each=r))
ta <- merge(index, ta, by = c("i", "j"), all.x = TRUE, sort=FALSE)
ta <- ta[ta$x != 0 & !is.na(ta$x),]
sparse.matrix(i=ta$i, j=ta$j, x=ta$x, dim=c(r,c))
}
# Define a function %*% to multiply sparse matrix
`%*%.default` = .Primitive("%*%")
`%*%` = function(x,...){
UseMethod("%*%",x)
}
`%*%` <- function(x, y) {
UseMethod("%*%", x)
}
`%*%.sparse.matrix` <- function(a,b) {
#UseMethod("%*%", a)
# Check the type of b
if (!inherits(b, "sparse.matrix")) {
stop("y argument is not a sparse matrix type.")
}
# Check whether the dimensions of a and b agree
if (attr(a$j, "label") != attr(b$i, "label")) {
stop('The dimensions of the two input matrix do not match')
}
if (attr(a$i, "label") == 0 || attr(a$j, "label") == 0 ||
attr(b$i, "label") == 0 || attr(b$j, "label") == 0) {
arow <- max(a$i); acol <- max(a$j)
brow <- max(b$i); bcol <- max(b$j)
} else {
arow <- attr(a$i, "label"); acol <- attr(a$j, "label")
brow <- attr(b$i, "label"); bcol <- attr(b$j, "label")
}
# Create an index of full-rank cols and rows
index <- data.frame(i=rep(1:max(arow, brow)),
j=rep(1:max(acol, bcol), each=max(arow, brow)))
c <- merge(index, a, by = c("i", "j"), all.x = TRUE)
c <- merge(c, b, by = c("i", "j"), all = TRUE, suffixes = c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
for (u in 1:arow) {
for (v in 1:bcol) {
c$x[c$i==u & c$j==v] <- sum(c$x1[c$i==u] * c$x2[c$j==v])
}
}
c <- c[c$x != 0 & !is.na(c$x),]
c <- c[, c("i", "j", "x")]
sparse.matrix(i=c$i, j=c$j, x=c$x, dim=c(attr(a$i, "label"), attr(b$j, "label")))
}
library(testthat)
context('Test the sparse matrix functions')
# If no dimensions are given, assume the largest coordinates are the
# dimensions.
sm0 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(1, 1))
sm1 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(3, 1), dims = c(3, 2))
sm2 <- sparse.matrix(i = c(1, 2, 2), j = c(1, 1, 2), x = c(4.4, 1.2, 3),
dims = c(2, 3))
sm3 <- sparse.matrix(i = rep(1, 3), j = 1:3, x = 1:3, dims = c(2, 3))
test_that("We have sparse.matrix objects.", {
expect_is(sm0, "sparse.matrix")
expect_is(sm1, "sparse.matrix")
expect_is(sm2, "sparse.matrix")
})
test_that("We can add sparse matrices.", {
expect_equal(sm0 + sm0,
sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(2, 2),
dims = c(2, 1)))
expect_equal(sm2 + sm3,
sparse.matrix(i = c(rep(1:2, 2), 1), j = c(1, 1, 2, 2, 3),
x = c(5.4, 1.2, 2, 3, 3)))
expect_error(sm2 + sm0)
})
test_that("We can multiply and transpose", {
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
expect_error(sm1 %*% sm1)
expect_equal(t(sm1) %*% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
})
library(devtools)
test()
sm1 %*% sm3
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
