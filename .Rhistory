x <- runif(10000, 0, 10)
plot(ecdf(x))
rmarkdown
library(rmarkdown)
install.packages("rmarkdown")
105/50.95*(8.95+9.75)
105/50.95*(8.95+9.75+2)
setwd("~/Documents/Master2-2/BIS 557-Computational Statistics/homework 1/bis557")
rm(list=())
ls)
ls()
rm(list=ls())
setwd("~/Documents/Master2-2/BIS 557-Computational Statistics/homework 1/bis557")
library(devtools)
devtools::test()
1 - (0.57*0.92+0.35*0.9+0.08*0.65)/(0.57*0.92 + 0.35*0.9 + 0.08*0.85)
(0.57*0.92+0.35*0.9+0.08*0.65)/(0.57*0.92 + 0.35*0.9 + 0.08*0.85)
0.99*(0.52*0.36 + 0.48*0.18) + 0.01*1
*(0.52*0.36 + 0.48*0.18)
(0.52*0.36 + 0.48*0.18)
1-0.27
0.01/0.73
0.99*(0.52*(0.9*0.36 + 0.1*0.2) + 0.48*(0.02*0.71 + 0.98*0.18)) + 0.01*1
0.52*0.36 + 0.48*0.2
0.52*0.71 + 0.18*0.2
knitr::opts_chunk$set(echo = TRUE)
# Define likelihood function X|theta
lik <- dbinom(x = 56, size = n, prob = ths)
n <- 100
# Define prior distribution of theta
ths <- seq(0,1,by=.001)
# Define likelihood function X|theta
lik <- dbinom(x = 56, size = n, prob = ths)
lik
?dbinom
plot(ths,lik)
# Define prior distribution of theta
ths <- seq(0,1,by=.001)
prior <- rep(1/n, n)
prior
# Define posterior probabilities
post <- prior*lik/sum(prior*lik)
n <- 100
ths <- seq(0,1,by=.001)
# Define likelihood function X|theta
lik <- dbinom(x = 56, size = n, prob = ths)
# Define prior distribution
prior <- rep(1/n, n)
# Define posterior probabilities
post <- prior*lik/sum(prior*lik)
length(lik)
length(prior)
n
lik <- dbinom(x = 56, size = n, prob = ths)
length(lik)
n <- 100
# Define prior distribution
ths <- seq(0,1,by=.001)
nth <- length(ths)
prior <- rep(1/nth, nth)
# Define likelihood function X|theta
lik <- dbinom(x = 56, size = n, prob = ths)
# Define posterior probabilities
post <- prior*lik/sum(prior*lik)
n <- 100
# Define prior distribution
ths <- seq(0,1,by=.001)
nth <- length(ths)
prior <- rep(1/nth, nth)
# Define likelihood function X|theta
lik <- dbinom(x = 56, size = n, prob = ths)
# Define posterior probabilities
post <- prior*lik/sum(prior*lik)
library(MASS)
truehist(post)
# Plot posterior distribution
myplot <- function(x, y){
plot(x, y, type="h", xlab = deparse(substitute(x)), ylab = deparse(substitute(y)))
points(x, y, pch=20)
}
myplot(ths, post)
# A function that calculate posterior probilities and make a plot
plot.posterior <- function(n) {
library(MASS)
# Define prior distribution
ths <- seq(0,1,by=.001)
nth <- length(ths)
prior <- rep(1/nth, nth)
# Define likelihood function X|theta
lik <- dbinom(x = 56, size = n, prob = ths)
# Define posterior probabilities
post <- prior*lik/sum(prior*lik)
# Plot posterior distribution
myplot <- function(x, y){
plot(x, y, type="h", xlab = deparse(substitute(x)), ylab = deparse(substitute(y)))
points(x, y, pch=20)
}
myplot(ths, post)
}
ns <- c(100, 400, 1600)
sapply(ns, plot.posterior)
plot.posterior <- function {
plot.posterior <- function {
posts <- list(n1=NULL, n2=NULL, n3=NULL)
posts
posts[[1]]
ns <- c(100, 400, 1600)
# Define prior distribution
ths <- seq(0,1,by=.001)
nth <- length(ths)
prior <- rep(1/nth, nth)
posts <- list(n1=NULL, n2=NULL, n3=NULL)
# Calculate posterior probilities
for (i in 1:3) {
library(MASS)
# Define likelihood function X|theta
lik <- dbinom(x = 56, size = ns[i], prob = ths)
# Define posterior probabilities
posts[[i]] <- prior*lik/sum(prior*lik)
}
posts
posts[[1]]
dim(posts)
?apply
?lapply
lapply(posts, function(x) myplot(ths, x))
ns
posts[[1]]
posts[[1]] > 0.5
which(posts[[1]] > 0.5)
post <- posts[[1]]
which(post > 0.5)
post > 0.5
lapply(posts, function(post) sum(post[which(post>0.5)]))
posts
# Sample size
ns <- c(100, 400, 1600)
# Define prior distribution
ths <- seq(0,1,by=.001)
nth <- length(ths)
prior <- rep(1/nth, nth)
posts <- list(n1=NULL, n2=NULL, n3=NULL)
# Calculate posterior probilities
for (i in 1:3) {
library(MASS)
# Define likelihood function X|theta
lik <- dbinom(x = 56, size = ns[i], prob = ths)
# Define posterior probabilities
posts[[i]] <- prior*lik/sum(prior*lik)
}
# Plot posterior distribution
myplot <- function(x, y){
plot(x, y, type="h", xlab = deparse(substitute(x)), ylab = deparse(substitute(y)))
points(x, y, pch=20)
}
lapply(posts, function(post) myplot(ths, post))
ths
lik
hist(lik)
lik <- dbinom(x = 56, size = 100, prob = ths)
plot(ths,lik)
ths
ths <- seq(0,1,by=.005)
ths
ths <- seq(0,1,by=.001)
ths
i=1
ns[i]
dbinom(x = 56, size = ns[i], prob = ths)
# Define likelihood function X|theta
lik <- dbinom(x = 56, size = ns[i], prob = ths)
lik > 0.5
ths <- seq(0,1,by=.005)  # grid of theta values
# e.g. could change to by=.001 for more precise results
length(ths)
head(ths)
tail(ths)
#' ### Likelihood function
#'
#' These correspond to the "second step probabilities" in the frog problem.
lik <- dbinom(x = 56, size = 100, prob = ths)
plot(ths,lik)
#' ### Maximum likelihood estimator
# zoom in on likelihood
ind <- which(ths > .5 & ths < .6)
plot(ths[ind], lik[ind])
abline(v=.56, lty=2)
#' Looks like the maximum occurs at (or very near to) theta = 0.56.
#' ### Prior
nth <- length(ths)
prior <- rep(1/nth, nth)
plot(ths, prior)
#' In class I wanted to make a nicer plot that looks more like a probability mass function.  Here is a slightly fancier version of that function.
#' (It is fancier in order to give axis labels that correspond to the arguments supplied.)
myplot <- function(x, y){
plot(x, y, type="h", xlab = deparse(substitute(x)), ylab = deparse(substitute(y)))
points(x, y, pch=20)
}
myplot(ths,prior)
#' ### Posterior probabilities
post <- prior*lik/sum(prior*lik)
plot(ths, post)
myplot(ths, post)
myplot(ths, lik)
sum(post[which(ths > 0.5)])
lapply(posts, function(post) sum(post[which(ths>0.5)]))
lapply(posts, function(post) sum(post[which(ths>0.5)]))
ns
cumsum(post[[1]])
?cumsum
post[[1]]
cumsum(posts[[1]])
i <- 1
cumsum(post[[i]]) > 0.95
cumsum(post[[i]])
cumsum(posts[[i]]) > 0.95
which(cumsum(posts[[i]]) > 0.95)
which(cumsum(posts[[i]]) > 0.95)[1]
for (i in 1:3) {
which(cumsum(posts[[i]]) > 0.95)[1]
}
for (i in 1:3) {
which(cumsum(posts[[i]]) > 0.95)[1]
}
which(cumsum(posts[[i]]) > 0.95)[1]
for (i in 1:3) {
which(cumsum(posts[[i]]) > 0.95)[1]
}
for (i in 1:3) {
which(cumsum(posts[[i]]) > 0.95)[1]
}
for (i in 1:3) {
print(which(cumsum(posts[[i]]) > 0.95)[1])
}
for (i in 1:3) {
position <- which(cumsum(posts[[i]]) > 0.95)[1]
print(position)
}
ths[1:position]
cumsum(ths[1:position])
cumsum(post[[1]][1:position])
post[[1]][1:position]
cumsum(posts[[1]][1:position])
for (i in 1:3) {
position <- which(cumsum(posts[[i]]) > 0.95)[1]
ths[1:position]
print(position)
}
cumsum(posts[[1]][1:640])
for (i in 1:3) {
position <- which(cumsum(posts[[i]]) > 0.95)[1]
c(ths[1], ths[position])
}
for (i in 1:3) {
position <- which(cumsum(posts[[i]]) > 0.95)[1]
interval <- c(ths[1], ths[position])
print(interval)
}
length(ths)
# Define prior distribution
ths <- seq(0,1,by=.001)
for (i in 1:3) {
position <- which(cumsum(posts[[i]]) > 0.95)[1]
interval <- c(ths[1], ths[position])
print(interval)
}
knitr::opts_chunk$set(echo = TRUE)
# Sample size
ns <- c(100, 400, 1600)
# Define prior distribution
ths <- seq(0,1,by=.001)
nth <- length(ths)
prior <- rep(1/nth, nth)
posts <- list(n1=NULL, n2=NULL, n3=NULL)
# Calculate posterior probilities
for (i in 1:3) {
library(MASS)
# Define likelihood function X|theta
lik <- dbinom(x = 56, size = ns[i], prob = ths)
# Define posterior probabilities
posts[[i]] <- prior*lik/sum(prior*lik)
}
# Plot posterior distribution
myplot <- function(x, y){
plot(x, y, type="h", xlab = deparse(substitute(x)), ylab = deparse(substitute(y)))
points(x, y, pch=20)
}
lapply(posts, function(post) myplot(ths, post))
lapply(posts, function(post) sum(post[which(ths>0.5)]))
for (i in 1:3) {
position <- which(cumsum(posts[[i]]) > 0.95)[1]
interval <- c(ths[1], ths[position])
print(interval)
}
for (i in 1:3) {
position <- min(which(cumsum(posts[[i]]) > 0.95))
interval <- c(ths[1], ths[position])
print(interval)
}
intervals <- list(n1=NULL, n2=NULL, n3=NULL)
for (i in 1:3) {
position <- min(which(cumsum(posts[[i]]) > 0.95))
intervals[[i]] <- c(ths[1], ths[position])
}
intervals
?half
lapply(intervals, function(x) sum(x)/2)
knitr::opts_chunk$set(echo = TRUE)
library(devtools)
load_all()
setwd("~/Documents/Master2-2/BIS 557-Computational Statistics/homework 1/bis557")
load_all()
?expect_equivalent
?expect_identical
browseVignettes()
setwd("~/Documents/Master2-2/BIS 557-Computational Statistics/homework 1/bis557/vignettes")
use_vignette("homework-2")
library(devtools)
use_vignette("homework-2")
setwd("~/Documents/Master2-2/BIS 557-Computational Statistics/homework 1/bis557")
library(devtools)
use_vignette("homework-2")
devtools::use_vignette("homework-2")
devtools::use_vignette()
devtools::use_vignette("homework-2")
document()
setwd("~/Documents/Master2-2/BIS 557-Computational Statistics/homework 1/bis557")
install()
library(bis557)
document()
install(build_vignettes = TRUE)
library(dplyr)
iris %>% head
library(dplyr)
iris %>% head %>% tail(n = 3)
`%>%`(iris, head)
library(tibble)
library(tibble)
iris <- as_tibble(iris)
iris[,1] # Tibble allows this to return a data frame instead of a vector
as.data.frame(iris[,1]) # Tibble allows this to return a data frame instead of a vector
T1 <- rexp(1)
?rexp
pmin(T1, T2)
T1 <- rexp(5000, 1)
T2 <- rexp(5000, 2)
pmin(T1, T2)
library(MASS)
T1 <- rexp(5000, 1)
T2 <- rexp(5000, 2)
X <- pmin(T1, T2)
truehist(X)
?curve
curve(exp)
curve(exp(3))
truehist(X)
?dexp
rexp(nsims, 3)
nsims <- 5000
rexp(nsims, 3)
curve(rexp(nsims, 3))
?expr
x <- runif(nsims, 0, 3)
curve(dexp(x, rate = 3))
library(MASS)
nsims <- 5000
T1 <- rexp(nsims, rate = 1)
T2 <- rexp(nsims, rate = 2)
X <- pmin(T1, T2)
truehist(X)
x <- runif(nsims, 0, 3)
curve(dexp(x, rate = 3), add = TRUE)
library(MASS)
nsims <- 5000
T1 <- rexp(nsims, rate = 1)
T2 <- rexp(nsims, rate = 2)
X <- pmin(T1, T2)
truehist(X)
x <- runif(nsims, 0, 3)
curve(dexp(x, rate = 3), add = TRUE, col = "red", lwd = 2)
library(MASS)
nsims <- 5000
T1 <- rexp(nsims, rate = 1)
T2 <- rexp(nsims, rate = 2)
X <- pmin(T1, T2)
truehist(X)
x <- runif(nsims, 0.01, 3)
curve(dexp(x, rate = 3), add = TRUE, col = "red", lwd = 2)
library(MASS)
nsims <- 5000
T1 <- rexp(nsims, rate = 1)
T2 <- rexp(nsims, rate = 2)
X <- pmin(T1, T2)
truehist(X)
x <- runif(nsims, 0, 3)
curve(dexp(x, rate = 3), add = TRUE, col = "red", lwd = 2)
library(MASS)
nsims <- 5000
T1 <- rexp(nsims, rate = 1)
T2 <- rexp(nsims, rate = 2)
X <- pmin(T1, T2)
truehist(X)
x <- runif(nsims, 0.5, 3)
curve(dexp(x, rate = 3), add = TRUE, col = "red", lwd = 2)
library(MASS)
nsims <- 5000
T1 <- rexp(nsims, rate = 1)
T2 <- rexp(nsims, rate = 2)
X <- pmin(T1, T2)
truehist(X)
x <- runif(nsims, 0, 3)
curve(dexp(x, rate = 3), add = TRUE, col = "red", lwd = 2)
rm(x)
# x <- runif(nsims, 0, 3)
curve(dexp(x, rate = 3), add = TRUE, col = "red", lwd = 2)
library(MASS)
nsims <- 5000
T1 <- rexp(nsims, rate = 1)
T2 <- rexp(nsims, rate = 2)
X <- pmin(T1, T2)
truehist(X)
# x <- runif(nsims, 0, 3)
curve(dexp(x, rate = 3), add = TRUE, col = "red", lwd = 2)
library(MASS)
nsims <- 5000
T1 <- rexp(nsims, rate = 1)
T2 <- rexp(nsims, rate = 2)
X <- pmin(T1, T2)
truehist(X)
curve(dexp(x, rate = 3), add = TRUE, col = "red", lwd = 2)
# Simulate log normal distribution
nsims <- 100000
x <- rnorm(nsims)
y <- exp(x)
truehist(y)
# Overlay the PDF found in part(b)
# Simulate log normal distribution
nsims <- 100000
x <- rnorm(nsims)
y <- exp(x)
truehist(y)
# Overlay the PDF found in part(b)
curve(1/(sqrt(2*pi)*x) * exp(-0.5*(ln(x))^2), add = TRUE, col = "red", lwd = 2)
?log
# Simulate log normal distribution
nsims <- 100000
x <- rnorm(nsims)
y <- exp(x)
truehist(y)
# Overlay the PDF found in part(b)
curve(1/(sqrt(2*pi)*x) * exp(-0.5*(log(x,base = exp(1)))^2), add = TRUE, col = "red", lwd = 2)
knitr::opts_chunk$set(echo = TRUE)
# Sample size
ns <- c(100, 400, 1600)
# Define prior distribution
ths <- seq(0,1,by=.001)
nth <- length(ths)
prior <- rep(1/nth, nth)
posts <- list(n1=NULL, n2=NULL, n3=NULL)
# Calculate posterior probilities
for (i in 1:3) {
# Define likelihood function X|theta
lik <- dbinom(x = 56, size = ns[i], prob = ths)
# Define posterior probabilities
posts[[i]] <- prior*lik/sum(prior*lik)
}
# Plot posterior distribution
myplot <- function(x, y){
plot(x, y, type="h", xlab = deparse(substitute(x)), ylab = deparse(substitute(y)))
points(x, y, pch=20)
}
lapply(posts, function(post) myplot(ths, post))
lapply(posts, function(post) sum(post[which(ths>0.5)]))
intervals <- list(n1=NULL, n2=NULL, n3=NULL)
for (i in 1:3) {
lower <- man(which(cumsum(posts[[i]]) < 0.025))
upper <- min(which(cumsum(posts[[i]]) > 0.975))
intervals[[i]] <- c(ths[lower], ths[upper])
}
intervals <- list(n1=NULL, n2=NULL, n3=NULL)
for (i in 1:3) {
lower <- max(which(cumsum(posts[[i]]) < 0.025))
upper <- min(which(cumsum(posts[[i]]) > 0.975))
intervals[[i]] <- c(ths[lower], ths[upper])
}
intervals
lower
which(cumsum(posts[[i]]) < 0.025)
min(which(cumsum(posts[[i]]) > 0.025))
intervals <- list(n1=NULL, n2=NULL, n3=NULL)
for (i in 1:3) {
lower <- min(which(cumsum(posts[[i]]) > 0.025))
upper <- min(which(cumsum(posts[[i]]) >= 0.975))
intervals[[i]] <- c(ths[lower], ths[upper])
}
intervals
intervals <- list(n1=NULL, n2=NULL, n3=NULL)
for (i in 1:3) {
lower <- min(which(cumsum(posts[[i]]) > 0.025))
upper <- min(which(cumsum(posts[[i]]) >= 0.975))
intervals[[i]] <- c(ths[lower], ths[upper])
}
intervals
lapply(intervals, function(x) sum(x)/2)
qnorm(1-0.03/2)
qnorm(1-0.15)
(2*(2.170 + 1.036)^2 * 6.45 ^2)/4
qnorm(1-0.1)
(2*(2.170 + 1.282)^2 * 6.45 ^2)/4
qnorm(0.9)
qnorm(0.975)
(1.28+1.96)^2
