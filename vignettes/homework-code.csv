user,code
a," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats model.matrix  #' @export  linear_model <- function(formula, data) {   a<- all.vars(formula)   #create response varible y   y <- data[,a[1]]   #create design matrix containing explanatory varibls and intercept   mm <- model.matrix(formula, data)   x<-mm   output <- list()   output$coefficients <- qr.coef(qr(x),y)   #create lm object   class (output) = ""lm""   return(output) }    "
b," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats model.matrix #' @export #load(""/Users/shawnieshan/Desktop/BIS557/bis557/data/lm_patho.rda"") #lmod<-lm(lm_patho$y~.,data=lm_patho) #summary(lmod)  linear_model <- function(formula, data) {   #browser()   all<-all.vars(formula)   x<-model.matrix(formula, data)   y<-data[,all[1]]   #svd_output <- svd(x)   #U <- svd_output[[""u""]]   #Sinv <- diag(1 / svd_output[[""d""]])   #V <- svd_output[[""v""]]   #pseudo_inv <- V %*% Sinv %*% t(U)   #betahat <- pseudo_inv %*% y   #colnames(betahat) <- ""regression coefficient""   #rownames(betahat) <- c(""Sepal.Width"",""Patal.Length"",""Petal.Width"",""Species_versicolor"",""Species_virginica"")   #print(betahat) #lm(formula, data)   beta<-list()   #beta$call=call(""linear_model"", formula)   beta$coefficients=qr.coef(qr(x),y)   class(beta)=""lm""   return(beta) } #linear_model(y~.,data=lm_patho)  #test #setwd(""/Users/shawnieshan/Desktop/BIS557/bis557"")  #library(devotions) #check() #library(testthat) #test()               "
c,"#' Fit a Linear Model #' #' @description This function passes parameters to the linear_model function. #' @param formula A formula #' @param data A data.frame #' @return An lm object #' @importFrom stats as.formula model.matrix terms #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export  linear_model <- function(formula, data) {   f = all.vars(formula)      ## Get the response variable and the design matrix   X = model.matrix(formula, data = data)   Y = data[, f[1]]      ## Create a list to store all components of an object class of ""lm""   fit_linear_model = list()      ## All components of an object class of ""lm""   fit_linear_model$coefficients = qr.coef(qr(X), Y)   fit_linear_model$fitted.values = X %*% fit_linear_model$coefficients   fit_linear_model$residuals = fit_linear_model$y - fit_linear_model$fitted.values   fit_linear_model$rank = ncol(X)   fit_linear_model$weights = NULL   fit_linear_model$df.residual = nrow(X) - ncol(X)   fit_linear_model$call = call(""linear_model"", formula)   fit_linear_model$terms = terms(x = formula, data = data)   fit_linear_model$contrasts = NULL   fit_linear_model$xlevels = NULL   fit_linear_model$offset = NULL   fit_linear_model$x = X   fit_linear_model$y = Y   fit_linear_model$model = formula   fit_linear_model$qr = qr(X)      ## Set the list as an object class of ""lm""   class(fit_linear_model) = ""lm""      ## Return the list   return(fit_linear_model) }"
d," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export linear_model <- function(formula, data) {   lm(formula, data) }"
e," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats lm #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export linear_model <- function(formula, data) {   #Generate the design matrix of X   X<-model.matrix(formula, data)      #Find y from the formula   y<-data[,all.vars(formula)[1]]      #Apply QR method to find beta and change beta to the same form as in lm   beta<-qr.solve(X,y)   beta[which(beta==0)] <- NA      #Initiate a model_fit list which has the same class characteristics as lm   model_fit<-list()      #Parameters in model_fit list   #Reference: https://www.rdocumentation.org/packages/stats/versions/3.5.1/topics/lm   model_fit$coefficients <- beta   model_fit$residuals<- y-X%*%beta   model_fit$fitted.values<-X%*%beta   model_fit$rank <- ncol(X)    model_fit$weights <- NULL   model_fit$df.residuals <- nrow(X) - ncol(X) #n-p   model_fit$qr <- qr(X)   model_fit$call <- call('lm',formula)   model_fit$terms <- terms(x = formula,data = data)   model_fit$contrasts <- NULL   model_fit$xlevels <- NULL   model_fit$offset <-NULL   model_fit$y <- y   model_fit$x <- X   model_fit$model = formula   model_fit$na.action <- NULL      #Cast the class of model_fit to lm   class(model_fit)<-""lm""      return(model_fit) }"
f," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats lm #' @import stats model.frame model.matrix #' @examples #' @export linear_model <- function(formula, data) {     X = stats::model.matrix(formula, data)     Y= stats::model.frame(formula,data)[,1]     beta <- qr.solve(X,Y)     for (i in 1:length(beta)){         if (beta[i] == 0)         beta[i] = NA              }     ret <- list()     ret$coefficients = c(beta)     class(ret) = ""lm""     return(ret) }"
g," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats model.matrix #' @export linear_model <- function(formula, data) {   coef<-list()   x_var<-all.vars(formula)   X<-model.matrix(formula, data)   Y<-data[,x_var[1]]      coef$coefficients=qr.coef(qr(X),Y)   class(coef)=""lm""   return(coef) }"
h," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats model.frame model.matrix #' @export linear_model <- function(formula, data) {   #Get X and Y matrix   mat <- model.frame(formula, data)   Y <- data.frame(mat[,1])   colnames(Y) <- names(mat[1])   X <- model.matrix(formula, data)      #Calculate coefficients   result <- list()   X_d <- qr(X)   result$coefficients <- qr.coef(X_d, Y)   class(result) <- 'lm'   result }"
i," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export linear_model <- function(formula, data) {   xm <- model.matrix(formula,data)      # Get the name of the y to extract y from the dataset   yname <- paste(as.list(formula)[[2]])   ym <- data[,yname]      # Calculate beta   beta <- qr.solve(xm, ym)      # Beta = 0 indicates colinearity; changed to NA   beta[beta == 0] <- NA      fit <- list()   fit$coefficients <- beta   fit$residuals <- ym - xm %*% beta   fit$fitted.values <- xm %*% beta   fit$rank <- qr(xm)$rank   fit$df.residuals <- nrow(xm) - qr(xm)$rank   fit$weights <- NULL   fit$qr <- qr(xm)   fit$call <- call(""linear_model"", formula)   fit$terms <- terms(x = formula, data = data)   fit$contrasts <- NULL   fit$xlevels <- NULL   fit$offset <- NULL   fit$y <- ym   fit$x <- xm   fit$model <- model.frame(data)   class(fit) <- ""lm""   return(fit) }  "
j," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats lm #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export linear_model = function(formula,data){   res = all.vars(formula)[1]   if( all.vars(formula)[-1] == '.'){     var = colnames(data)[colnames(data)!= res]   }   else{     var = all.vars(formula)[-1]   }   X = model.matrix(as.formula(paste(""~"", paste(var, collapse = "" + ""))), data = data)   Y = data[,res]   #beta = solve((t(X) %*% X)) %*% t(X) %*% Y   beta = qr.solve(X,Y)   beta[beta == 0] = NA   fitted = X %*% beta   residuals = Y - fitted   result = list(coefficients = beta, residuals = residuals, fitted.values = fitted, rank = ncol(X), weights = NULL, df.residual = nrow(X) - ncol(X), call = call('lm',formula), terms = terms(x = formula, data = data),contrasts = NA, xlelves = NA, offset = NA, y = Y, x = X, model = formula, na.action = NA, qr = qr(X))   class(result) = 'lm'   #browser()   return(result) }"
k,"#' Fit a linear model #' #' @description This function is my own implementation of the ""lm"" function in R. The implementation is based on the SVD method from Chapter 2 of A Computational Approach to Statistical Learning. #' @description This method only uses the covariates that are linearly independent, using the ""alias"" function from the ""stats"" package to perform this test. #' @param formula a formula #' @param data a data.frame #' @return An lm object, but only the coefficients (not the standard errors, t-values, or two-sided probabilities), so don't use summary() on this! #' @import stats  #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' fit #' @export linear_model <- function(formula, data) {   X <- stats::model.matrix(formula, data) #This is our model matrix of the data for the model   coef_out <- data.frame(rep(NA, ncol(X))) #Initialize the output   rownames(coef_out) <- colnames(X) #Naming the coefficients   y_index <- which(colnames(data) == as.character(formula)[2]) #This is where in the data we can find the response variable   y <- data[,y_index] #Get the vector of the response data      # Using the alias command to remove dependencies, as suggested by Cathy Xue   omitted <- rownames(stats::alias(formula, data)$Complete) #Alias removes the dependencies. This returns the columns to be omitted   Xred <- X[,setdiff(colnames(X), omitted)] #Remove the linearly dependent columns, to get a reduced data set      # Using Chapter 2, Section 5 of A Computational Approach to Statistical Learning:   svd_list <- svd(Xred)   sv <- svd_list[[""d""]] #The singular values of X   sigma_inverse <- diag(1/sv) #The sigma^-1 matrix, where sigma is a matrix of singular values in decreasing order   U <- svd_list[[""u""]] #U matrix of SVD   V <- svd_list[[""v""]] #V matrix of SVD   beta_hat <- V %*% sigma_inverse %*% t(U) %*% y   coef_out[colnames(Xred),1] <- beta_hat   colnames(coef_out) <- """"   coef_out <- t(coef_out) #Make horizontal for output   coef_out <- as.list(coef_out) #Make a list, as it would be in an lm object   names(coef_out) <- colnames(X) #Putting the names back      # Returning the lm object output   ret <- list() #Initialize the return object   class(ret) <- ""lm"" #Make the return object an lm object   #Assign the formula and data to the call field of the lm object. I used as.name to remove the quotes:   ret$call <- as.name(paste(c(""linear_model(formula = "", formula, "", data = "", deparse(substitute(data)), "")""), sep="""", collapse=""""))   ret$coefficients <- unlist(coef_out) #Assign the coefficients of this lm object to be the ones we determined earlier   return(ret) }"
l," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export  # linear_model3 <- function(formula, data){ #   fit <- lm(formula, data) #   return(fit) # }  linear_model <- function(formula, data) {   var = all.vars(formula)   y = data[, var[1]]   X = model.matrix(formula, data)      X_QR = qr(X)   beta = solve.qr(X_QR, y)   beta[which(beta == 0)] = NA      fitted = X %*% beta   residuals = y - fitted   linear_model_fit = list(coefficients = beta, residals = residuals, fitted.values = fitted,                  rank = ncol(X), weights = NULL, df.residual = nrow(X) - ncol(X),                   call = call('lm', formula), terms = terms(x = formula, data = data),                  contrasts = NA, xlevels = NA, offset = NA, y = y, x = X,                   model = formula, na.action = NA, qr = X_QR)   class(linear_model_fit) = 'lm'   return(linear_model_fit) }  linear_model2 <- function(formula, data) {   options(digits = 4)   var = all.vars(formula)   y = data[, var[1]]   X = model.matrix(formula, data)      X_svd = svd(X)   U = X_svd$u   V = X_svd$v   D_inverse = diag(1 / X_svd$d)   beta = V %*% D_inverse %*% t(U) %*% y   beta[which((beta - 0) < 1e-8)] = NA      my_coef = list(coefficients = beta, call = NA, rank = NA)   class(my_coef) = 'lm'   return(my_coef) }"
m," #' Fit a linear model #' #' @description This function use QR decomposition to solve OLS. #' @param formula formula of the regression model #' @param data a data.frame #' @return An lm object #' @importFrom stats lm #' @importFrom stats model.matrix #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export linear_model <- function(formula, data) {      # Create data   X_design <- model.matrix(formula, data)   y <- unlist(data[all.vars(formula)[1]])    # Solve beta via QR decomposition   beta_hat <- qr.solve(X_design, y)   beta_hat[beta_hat==0] <- NA    # Create a lm object    lm_list <- lm(formula,data)   lm_list$coefficients <- beta_hat   # lm_list <- list()   # lm_list$coefficients <- beta_hat   # lm_list$residuals <- y-X_design %*% beta_hat     # lm_list$fitted.values <- X_design %*% beta_hat   # lm_list$rank <- qr(X_design)$rank   # lm_list$weights <- NULL   # lm_list$df.residual <- nrow(X_design) - qr(X_design)$rank   # lm_list$call <- ""Self Written lm function""   # lm_list$terms <- formula   # lm_list$contrasts <- NULL   # lm_list$xlevels <- NULL   # lm_list$offset <- NULL   # lm_list$y <- y   # lm_list$x <- X_design   # lm_list$model <- NULL   # lm_list$na.action <- NULL   # lm_list$qr <- qr(X_design)   # class(lm_list) <- ""lm""   return (lm_list) }   # linear_model <- function(formula, data) { #   X_design <- model.matrix(formula, data) #   svd_object = svd(X_design) #   U <- svd_object[[""u""]] #   V <- svd_object[[""v""]] #   Sinv <- diag(1 / svd_object[[""d""]]) #   y <- unlist(data[all.vars(formula)[1]]) #   pseudo_inv <- V %*% Sinv %*% t(U) #   beta_hat <- pseudo_inv %*% y #   lm_list <- lm(formula,data) #   lm_list$coefficients <- beta_hat #   return (lm_list) # }"
n," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats lm #' @examples #' @export linear_model <- function(formula, data) {   form = all.vars(formula)   mat = model.matrix(formula,data = data)   res = data[,form[1]]   fit_lm_model =list()   fit_lm_model$coefficients =qr.coef(qr(mat),res)   class(fit_lm_model)=""lm""   return(fit_lm_model) }"
o,"#' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats lm #' @importFrom stats model.matrix terms #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export   linear_model <- function(formula, data) {   #use matrix to get x and y values - reference to the help from TA session and Hongyu Li   x= model.matrix(formula, data = data)   char = all.vars(formula)   y = data[,char[1]]      #solve the predicted coefficients - reference to the R documentation   coefficients = qr.coef(qr(x),y)      #solve the fitted value use x and coefficients   fitted.values = x %*% coefficients      #solve residuals by making subtraction   residuals = y - fitted.values      #create the result in a list   final = list(coefficients=coefficients,               residuals=residuals,              fitted.values= fitted.values,               rank = ncol(x),               weights = NULL,               df.residual = nrow(x)-ncol(x),               call = call(""linear_model"", formula),              terms = terms(x = formula, data = data),               contrasts = NULL,               xlevels = NULL,               offset = NULL,               y = y,               x = x,               model = formula,               na.action = NULL,              qr = qr(x))      #class the final list and return the result   class(final)='lm'   return(final) }  #linear_model(Sepal.Length~.,iris)"
p," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export linear_model <- function(formula, data) {   mf <- match.call(expand.dots = FALSE)   m <- match(c(""formula"", ""data""), names(mf), 0L)   mf <- mf[c(1L, m)]   mf$drop.unused.levels <- TRUE   mf[[1L]] <- as.name(""model.frame"")   mf <- eval(mf, parent.frame())   y <- model.response(mf, ""numeric"")   x <- model.matrix(formula, data)   n <- dim(x)[1]   p <- dim(x)[2]   udv <- svd(x)   if (n<p) {     x.inv <- udv$v[1:n,] %*% diag(1 / udv$d) %*% t(udv$u)     pseudo.inv <- rbind((x.inv %*% y), NA)     while(p-n > 1){       pseudo.inv <- rbind(pseudo.inv, NA)       p <- p - 1     }   }else {     x.inv <- udv$v %*% diag(1 / udv$d) %*% t(udv$u)     pseudo.inv <- x.inv %*% y   }   attr(pseudo.inv, ""names"") <- colnames(x)   x.pseudo.inv <- list(coefficients = pseudo.inv)   x.pseudo.inv }"
q," #' Fit a linear model #' #' @description This function passes parameters to the linear_model function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export linear_model <- function(formula, data) {   intercept<-as.data.frame(rep(1,nrow(data)))   formula_check<-as.character(formula)   if (""."" %in% formula_check){     formula_check<-formula_check   } else{     tm<-terms(formula)     var<-as.character(attr(tm, ""variables""))[-1]   }   # generate dataset for analysis   if (""."" %in% formula_check){     data<-data   } else {   data<-data[,match(var,colnames(data))]   }   # If factor variable exists, change factor variables to numeric variables   colno<-c()   for (i in 1:ncol(data)) {     if (class(data[,i])!=""numeric"" & class(data[,i])!=""integer""){       data[,i]<-as.factor(data[,i])       colno<-c(colno,i)       f<-levels(data[,i])       data[,i]<-as.character(data[,i])       for (j in 2:length(f)) {         v<-data[,i]         v[v==f[j]]<-1         v[v!=""1""]<-0         v<-as.numeric(v)         v<-as.data.frame(v)         colnames(v)<-paste(colnames(data)[i], f[j],sep = """")         data<-cbind(data,v)       }     }   }   if (length(colno)>0){     data<-data[,-colno]   } else {     data<-data   }   # calculate coefficients   if (""."" %in% formula_check){     y<-as.matrix((data[,match(formula_check[2],colnames(data))]))     x<-as.data.frame(data[,-match(formula_check[2],colnames(data))])     xvar<-colnames(x)     x<-as.matrix(cbind(intercept,x))     xqr<-qr(x)     coefficients<-qr.coef(xqr,y)     fit_model<-list()     fit_model$coefficients<-coefficients     fit_model$fitted.values<-x %*% fit_model$coefficients     fit_model$residuals<-fit_model$y - fit_model$fitted.values     fit_model$rank<-ncol(x)     fit_model$weights<-NULL     fit_model$df.residual<-nrow(x)-ncol(x)     fit_model$call<-call(""linear_model"", formula)     fit_model$terms<-terms(x = formula, data = data)     fit_model$contrasts<-NULL     fit_model$xlevels<-NULL     fit_model$offset<-NULL     fit_model$y<-y     fit_model$x<-y     fit_model$model<-formula     fit_model$qr<-qr(x)     class(fit_model)<-""lm""     return(fit_model)   } else {   resp<-attr(tm, ""response"")   yvar<-var[resp]   y<-as.matrix((data[,match(yvar,colnames(data))]))   x<-as.data.frame(data[,-match(yvar,colnames(data))])   xvar<-colnames(x)   x<-as.matrix(cbind(intercept,x))   xqr<-qr(x)   coefficients<-qr.coef(xqr,y)   fit_model<-list()   fit_model$coefficients<-coefficients   fit_model$fitted.values<-x %*% fit_model$coefficients   fit_model$residuals<-fit_model$y - fit_model$fitted.values   fit_model$rank<-ncol(x)   fit_model$weights<-NULL   fit_model$df.residual<-nrow(x)-ncol(x)   fit_model$call<-call(""linear_model"", formula)   fit_model$terms<-terms(x = formula, data = data)   fit_model$contrasts<-NULL   fit_model$xlevels<-NULL   fit_model$offset<-NULL   fit_model$y<-y   fit_model$x<-x   fit_model$model<-formula   fit_model$qr<-qr(x)   class(fit_model)<-""lm""   return(fit_model)   } }"
r," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats lm #' @importFrom stats model.matrix #' @importFrom stats model.frame #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export linear_model <- function(formula, data) {   # Get the design matrix X   x <- model.matrix(formula, data)      # Get the dependent variable y   model <- model.frame(formula, data)    y <- model[, 1]      # QR decomposition of design matrix   qrr <- qr(x)   qrr$tol <- 1e-07      # Generate coefficients   co <- qr.coef(qrr, y)      # Generate residuals   re <- qr.resid(qrr, y)   names(re) <- 1:length(re)      # Generate effects   eff <- qr.qty(qrr, y)   nameeff <- colnames(x)   nameeff <- nameeff[qrr$pivot[1:qrr$rank]]   names(eff) <- c(nameeff, rep("""", length(eff)-length(nameeff)))      # Generate fitted values   fit <- qr.fitted(qrr, y)   names(fit) <- 1: length(fit)      #Terms of the model   tm <- attr(model, ""terms"")      #Form the list   li <- list()   li$coefficients <- co   li$residuals <- re   li$effects <- eff   li$rank <- qrr$rank   li$fitted.values <- fit   li$assign <- attr(x, ""assign"")   li$qr <- qrr   li$df.residual <- nrow(x)-qrr$rank   li$contrasts <- attr(x, ""contrasts"")   li$xlevels <- .getXlevels(tm, model)   li$call <- match.call()   li$terms <- tm   li$model <- model   li$na.action <- attr(model, ""na.action"")   class(li) <- ""lm""   li }"
s,"#' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats model.matrix terms #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export  linear_model <- function(formula, data) {   #get the design matrix X   X<-model.matrix(formula, data)      #extract the response variable Y from the above matrix   #since for every matrix, Y variable is the first cololum, we get   var<-all.vars(formula)   Y<-data[,var[1]]      #use qr function to decompose the matrix and find coefficients as beta   beta<-qr.solve(X,Y)   beta[which(beta==0)] <- NA      #fit the coponents of lm model into a list, and set the class as lm   #if I cannot get the value, I would just assign it as NULL (got help from Hongyu Li)      lm_result = list(     coefficients = beta, residals = X %*% beta, fitted.values = Y - X %*% beta, rank = ncol(X),      df.residual = nrow(X) - ncol(X), call = call('lm', formula),  weights = NULL,     y = Y, x = X, model = formula, na.action = NA, qr = qr(X),     terms = terms(x = formula, data = data), contrasts = NA, xlevels = NA, offset = NA     )      class(lm_result) <- 'lm'   #get the final result   return(lm_result) }"
t," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats lm #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export linear_model <- function(formula, data) {   mm<-model.matrix(formula,data)   mf<-model.frame(formula, data)   y<-mf[as.integer(row.names(mm)),1]   QR<-qr(mm)      ##coefficients   b<-qr.coef(QR,y)      ##lm.object   flm<-list()      ##residuals   mm2<-mm[,!is.na(b)]   b2<-b[!is.na(b)]   residuals<-as.vector(y-mm2%*%b2)      ##effects    effects<-qr.qty(QR,y)      ## rank   the rank of design matrix   rank<-QR$rank      ##fitted.values   fitted.values<-as.vector(mm2%*%b2)      ##assign    assign<-attr(QR$qr,""assign"")      ##qr  QR  qr qraux pivot  tol rank   qr<-QR      ##df.residual   df.residual<-dim(mm2)[1]-dim(mm2)[2]      ##contrasts    contrasts<-attr(QR$qr,""contrasts"")      ##xlevels   xlevels<-.getXlevels(terms(formula,data=data),m=mf)      ##call   call = match.call()                        ##terms   terms<-terms(formula,data=data)      ##model    model<-mf[as.integer(row.names(mm)),]         flm <- list(coefficients = b,               residuals=residuals,               effects=effects,               rank=rank,               fitted.values=fitted.values,               assign=assign,               qr=qr,               df.residual=df.residual,               contrasts=contrasts,               xlevels=xlevels,               call=call,               terms=terms,               model=model)  class(flm)<-""lm""   return(flm) }     "
u,"#' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export   linear_model <- function(formula, data) {   # Construct Design Matrix X    X<-model.matrix(formula, data)   # Get Response Variable Y which is the first column of every dataset     Y<-model.frame(formula, data)[,1]   # Use QR decomposition to decompose the matrix X     QR <- qr(X)     # Calculate the beta      beta <- solve.qr(QR, Y)     beta[which(beta==0)] <- NA   # Put beta into a list and set the class to lm (discussed with Patty Zhang)       l = list(coefficients = beta, residals = X %*% beta, fitted.values = Y - X %*% beta, rank = ncol(X),    df.residual = nrow(X) - ncol(X), call = call('lm', formula),  weights = NULL, y = Y, x = X,       model = formula, na.action = NA, qr = qr(X),terms = terms(x = formula, data = data))    class(l) <- ""lm""     # Return the result    return(l) }"
v," #' Fit a linear model #' #' @description This function passes parameters to the lm function. #' @param formula a formula #' @param data a data.frame #' @return An lm object #' @importFrom stats #' @examples #' fit <- linear_model(Sepal.Length ~., iris) #' summary(fit) #' @export linear_model <- function(formula, data) {     # Define y   y_name <- strsplit(as.character(formula),"" ~ "")[[2]]   y <- as.matrix(data[y_name])      # Define X and calculate svd of X   X <- stats::model.matrix(formula,data)   QR <- qr(X)    # Calculate beta hat   beta_hat <- t(solve.qr(QR,y))   beta_hat[beta_hat == 0] <- NA      # Store beta hat in a data frame for coefficients   coeff <- as.numeric(beta_hat)   names(coeff) <- colnames(beta_hat)      # Create an lm object to output   object <- list(call=paste(""lm(formula = "", format(formula),                              "", data = "", deparse(substitute(data)), "")"", sep=""""),                   coefficients=coeff)   class(object) <- ""lm""   return(object)  }"
